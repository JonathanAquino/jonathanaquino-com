Title: Pragmatic Software Development Tips
Start: 2010-05-21
1. Care About Your Craft<br>Why spend your life developing software unless you care about doing it well?
2. Provide Options, Don’t Make Lame Excuses<br>Instead of excuses, provide options. Don’t say it can’t be done; explain what can be done.
3. Be a Catalyst for Change<br>You can’t force change on people. Instead, show them how the future might be and help them participate in creating it.
4. Make Quality a Requirements Issue<br>Involve your users in determining the project’s real quality requirements.
5. Critically Analyze What You Read and Hear<br>Don’t be swayed by vendors, media hype, or dogma. Analyze information in terms of you and your project.
6. DRY—Don’t Repeat Yourself<br>Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
7. Eliminate Effects Between Unrelated Things<br>Design components that are self-contained, independent, and have a single, well-defined purpose.
8. Use Tracer Bullets to Find the Target<br>Tracer bullets let you home in on your target by trying things and seeing how close they land.
9. Program Close to the Problem Domain<br>Design and code in your user’s language.
10. Iterate the Schedule with the Code<br>Use experience you gain as you implement to refine the project time scales.
11. Use the Power of Command Shells<br>Use the shell when graphical user interfaces don’t cut it.
12. Always Use Source Code Control<br>Source code control is a time machine for your work—you can go back.
13. Don’t Panic When Debugging<br>Take a deep breath and THINK! about what could be causing the bug.
14. Don’t Assume It—Prove It<br>Prove your assumptions in the actual environment—with real data and boundary conditions.
15. Write Code That Writes Code<br>Code generators increase your productivity and help avoid duplication.
16. Design with Contracts<br>Use contracts to document and verify that code does no more and no less than it claims to do.
17. Use Assertions to Prevent the Impossible<br>Assertions validate your assumptions. Use them to protect your code from an uncertain world.
18. Finish What You Start<br>Where possible, the routine or object that allocates a resource should be responsible for deallocating it.
19. Configure, Don’t Integrate<br>Implement technology choices for an application as configuration options, not through integration or engineering.
20. Analyze Workflow to Improve Concurrency<br>Exploit concurrency in your user’s workflow.
21. Always Design for Concurrency<br>Allow for concurrency, and you’ll design cleaner interfaces with fewer assumptions.
22. Use Blackboards to Coordinate Workflow<br>Use blackboards to coordinate disparate facts and agents, while maintaining independence and isolation among participants.
23. Estimate the Order of Your Algorithms<br>Get a feel for how long things are likely to take before you write code.
24. Refactor Early, Refactor Often<br>Just as you might weed and rearrange a garden, rewrite, rework, and re-architect code when it needs it. Fix the root of the problem.
25. Test Your Software, or Your Users Will<br>Test ruthlessly. Don’t make your users find bugs for you.
26. Don’t Gather Requirements—Dig for Them<br>Requirements rarely lie on the surface. They’re buried deep beneath layers of assumptions, misconceptions, and politics.
27. Abstractions Live Longer than Details<br>Invest in the abstraction, not the implementation. Abstractions can survive the barrage of changes from different implementations and new technologies.
28. Don’t Think Outside the Box—Find the Box<br>When faced with an impossible problem, identify the real constraints. Ask yourself: ``Does it have to be done this way? Does it have to be done at all?’‘
29. Some Things Are Better Done than Described<br>Don’t fall into the specification spiral—at some point you need to start coding.
30. Costly Tools Don’t Produce Better Designs<br>Beware of vendor hype, industry dogma, and the aura of the price tag. Judge tools on their merits.
31. Don’t Use Manual Procedures<br>A shell script or batch file will execute the same instructions, in the same order, time after time.
32. Coding Ain’t Done ‘Til All the Tests Run<br>‘Nuff said.
33. Test State Coverage, Not Code Coverage<br>Identify and test significant program states. Just testing lines of code isn’t enough.
34. English is Just a Programming Language<br>Write documents as you would write code: honor the DRY principle, use metadata, MVC, automatic generation, and so on.
35. Gently Exceed Your Users’ Expectations<br>Come to understand your users’ expectations, then deliver just that little bit more.
36. Think! About Your Work<br>Turn off the autopilot and take control. Constantly critique and appraise your work.
37. Don’t Live with Broken Windows<br>Fix bad designs, wrong decisions, and poor code when you see them.
38. Remember the Big Picture<br>Don’t get so engrossed in the details that you forget to check what’s happening around you.
39. Invest Regularly in Your Knowledge Portfolio<br>Make learning a habit.
40. It’s Both What You Say and the Way You Say It<br>There’s no point in having great ideas if you don’t communicate them effectively.
41. Make It Easy to Reuse<br>If it’s easy to reuse, people will. Create an environment that supports reuse.
42. There Are No Final Decisions<br>No decision is cast in stone. Instead, consider each as being written in the sand at the beach, and plan for change.
43. Prototype to Learn<br>Prototyping is a learning experience. Its value lies not in the code you produce, but in the lessons you learn.
44. Estimate to Avoid Surprises<br>Estimate before you start. You’ll spot potential problems up front.
45. Keep Knowledge in Plain Text<br>Plain text won’t become obsolete. It helps leverage your work and simplifies debugging and testing.
46. Use a Single Editor Well<br>The editor should be an extension of your hand; make sure your editor is configurable, extensible, and programmable.
47. Fix the Problem, Not the Blame<br>It doesn’t really matter whether the bug is your fault or someone else’s—it is still your problem, and it still needs to be fixed.
48. ``select’’ Isn’t Broken<br>It is rare to find a bug in the OS or the compiler, or even a third-party product or library. The bug is most likely in the application.
49. Learn a Text Manipulation Language<br>You spend a large part of each day working with text. Why not have the computer do some of it for you?
50. You Can’t Write Perfect Software<br>Software can’t be perfect. Protect your code and users from the inevitable errors.
51. Crash Early<br>A dead program normally does a lot less damage than a crippled one.
52. Use Exceptions for Exceptional Problems<br>Exceptions can suffer from all the readability and maintainability problems of classic spaghetti code. Reserve exceptions for exceptional things.
53. Minimize Coupling Between Modules<br>Avoid coupling by writing ``shy’’ code and applying the Law of Demeter.
54. Put Abstractions in Code, Details in Metadata<br>Program for the general case, and put the specifics outside the compiled code base.
55. Design Using Services<br>Design in terms of services—independent, concurrent objects behind well-defined, consistent interfaces.
56. Separate Views from Models<br>Gain flexibility at low cost by designing your application in terms of models and views.
57. Don’t Program by Coincidence<br>Rely only on reliable things. Beware of accidental complexity, and don’t confuse a happy coincidence with a purposeful plan.
58. Test Your Estimates<br>Mathematical analysis of algorithms doesn’t tell you everything. Try timing your code in its target environment.
59. Design to Test<br>Start thinking about testing before you write a line of code.
60. Don’t Use Wizard Code You Don’t Understand<br>Wizards can generate reams of code. Make sure you understand all of it before you incorporate it into your project.
61. Work with a User to Think Like a User<br>It’s the best way to gain insight into how the system will really be used.
62. Use a Project Glossary<br>Create and maintain a single source of all the specific terms and vocabulary for a project.
63. Start When You’re Ready<br>You’ve been building experience all your life. Don’t ignore niggling doubts.
64. Don’t Be a Slave to Formal Methods<br>Don’t blindly adopt any technique without putting it into the context of your development practices and capabilities.
65. Organize Teams Around Functionality<br>Don’t separate designers from coders, testers from data modelers. Build teams the way you build code.
66. Test Early. Test Often. Test Automatically.<br>Tests that run with every build are much more effective than test plans that sit on a shelf.
67. Use Saboteurs to Test Your Testing<br>Introduce bugs on purpose in a separate copy of the source to verify that testing will catch them.
68. Find Bugs Once<br>Once a human tester finds a bug, it should be the last time a human tester finds that bug. Automatic tests should check for it from then on.
69. Build Documentation In, Don’t Bolt It On<br>Documentation created separately from code is less likely to be correct and up to date.
70. Sign Your Work<br>Craftsmen of an earlier age were proud to sign their work. You should be, too.
